# DI контейнер

Подробнее о работе Dependency Injection можно прочитать на странице, посвящённой
[контейнеру Railt](/app/container), а на этой странице приводится лишь краткая 
информация о способах настройки внешнего контейнера.

Railt [содержит реализацию DI-контейнера](/app/container), который предоставляет 
основной механизм Dependency Injection. Реализация Railt позволяет наследовать 
состояние (или проксировать) любой другой PSR-совместимой реализации. Это 
будет особенно полезно при использовании Railt внутри Laravel, Symfony, Zend 
или любых других фреймворков, основой которых является 
[PSR-11 контейнер](https://www.php-fig.org/psr/psr-11/).

Для того, чтобы передать оригинальный контейнер в приложение - 
воспользуйтесь вторым аргументом класса `Application`.

```php
<?php
// Parent PSR-11 compatible container
$parent = new AnyPSR11Container();

$app = new Railt\Foundation\Application($debug, $parent);

// Railt container
$railt = $app->getContainer();
```

## Логика взаимодействия с внешними контейнерами

Railt обеспечивает "проксирование" запросов в родительский контейнер в том 
случае, если какая-либо сущность не была объявлена или переопределна в коренвой
реализации.

Пример получения сущности из контейнера Railt `$railt->get(Entity::class)`:
- Проверка существования сущности `$railt->has(Entity::class)`.
  - В случае положительного срабатывания возвращается требуемое значение.
- Проверка существования сущности в родительском контейнере `$parent->has(Entity::class)`.
  - В случае положительного срабатывания возвращается требуемое значение.
- В том случае, если сущность не найдедена - выбрасывается исключение `Psr\Container\NotFoundExceptionInterface`.

!> Обратите внимание, что сервисы Symfony, имеющие параметр `public: false` недоступны через методы `get` и `has`, 
а значит Railt Container о них ничего не знает.

