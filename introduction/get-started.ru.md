# Быстрый старт

После установки нужных компонентов мы можем приступить к написанию 
простого GraphQL сервера.

Для запуска приложения нам не нужно никаких фреймворков или CMS. 
Мы можем сразу же приступить к работе, игнорируя остальное окружение.
Первым делом давайте создадим `index.php` файл.

```php
<?php

use Railt\Io\File;
use Railt\Http\Factory;
use Railt\Foundation\Application;
use Railt\Foundation\Config\Composer;

/*
|--------------------------------------------------------------------------
| Регистрация автозагрузчика
|--------------------------------------------------------------------------
|
| Composer обеспечивает удобный, автоматически созданный загрузчик
| классов для нашего приложения. Мы просто подключим его здесь, так что
| нам не нужно было бы беспокоиться о способе загрузки любого из наших
| классов позже.
|
*/

require __DIR__ . '/vendor/autoload.php';

/*
|--------------------------------------------------------------------------
| Запуск приложения
|--------------------------------------------------------------------------
|
| Следующий код загружает приложение и готовит его к использованию, 
| чтобы мы могли его обработать запрос и отправить ответ обратно в браузер 
| на радость нашим пользователям.
|
*/

$app = new Application(true);

$app->configure(Composer::fromDiscovery());


/*
|--------------------------------------------------------------------------
| Создание нового соединения
|--------------------------------------------------------------------------
|
| Каждый GraphQL запрос - это "соединение", которое содержит уникальный 
| идентификатор клиента, позволяющий понять кто именно отправил запрос
| и сопоставить его с ответом. 
|
| Более глубокое понимания этого объекта будет раскрыто во время 
| реализации "подписок", а сейчас нам достаточно иметь ввиду, что 
| "соединение" - это объект, принимающий все GraphQL запросы и 
| возвращющий соответсвующие ответы.
|
*/

$connection = $app->connect(File::fromPathname(__DIR__ . '/schema.graphqls'));


/*
|--------------------------------------------------------------------------
| Парсинг входящих запросов
|--------------------------------------------------------------------------
|
| В рамках одного HTTP запроса у нас могут присутсвовать несколько GraphQL 
| запросов. Такую логику работы именуют "батчингом", а реализовывать её 
| на клиенте может, например, Apollo.
|
| Метод `createFromGlobals`, в данном случае, распаковывает запросы из 
| глобальных $_GET и $_POST переменных, а также читает php://input поток. 
|
| Обратите внимание, что использование этого метода в рамках постоянных
| соединений, например на WebSocket серверах - недопустимо.
|
*/

$factory = Factory::createFromGlobals();

/*
|--------------------------------------------------------------------------
| Формирование ответа
|--------------------------------------------------------------------------
|
| Так как GraphQL запросов у нас бывает несколько, то требуется 
| сформировать корректный ответ, объединяющий в себе несколько ответов.
| Для этого, мы воспользуемся уже сгенерированным фектори-объектом
| и просто передадим сформированный набор запросов созданному ранее 
| соединению.
|
| В качестве результата метода всегда будет один корректный ответ, вне 
| зависимости от того, является ли запрос совершенно обычным, или
| содержит коллекцию из нескольких.
|
*/

$response = $factory->request($connection);

/*
|--------------------------------------------------------------------------
| Формирование HTTP ответа
|--------------------------------------------------------------------------
|
| Для того, чтобы сформировать корректный HTTP ответ, содержащий нужные 
| заголовки - достаточно воспользовать методом отправки.
|
*/
$response->send();
```

После создания логики обработки запросов и отправки ответов нам 
нужно создать нашу первую схему приложения. Для этого создадим 
файл `schema.graphqls` и положим его рядом с `index.php`, наполнив 
следующим текстом:

```graphql
schema {
    query: Example
}

type Example {
    say(message: String = "Hello"): String!
        @route(action: "ExampleController@say")
}
```

Этот код должен предоставлять возможность выполнять запросы, вида `{ say("Привет!") }`.
Директива `@route(...)` ответчает за возможность делегировать возможность 
обработки запроса поля `say` произвольному PHP коду. По-этому, давайте его просто 
реализуем, например, в виде echo сервера (т.е. будем присылать в ответ тоже 
самое, что и в запросе, например сообщение `{"data": {"say": "Привет!"}}`).

```php
class ExampleController
{
    public function say(string $message): string
    {
        return $message;
    }
}
```

!> Обратите внимание, что класс `ExampleController` должен быть 
доступен для автозагрузки Composer'ом, либо быть подключённым явно в `index.php`.

На этом наше первое приложение завершено!
