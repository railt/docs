# Модификаторы

Помимо самих типов, RL/SDL предоставляет два модификатора, 
которые описывают их характеристики во время определения 
типов у [полей](/language/types/field) и [аргументов](/language/types/argument).

## Non-Null

По умолчанию все типы в GraphQL имеют значение `NULL`;
Нулевое значение является допустимым ответом для всех вышеперечисленных типов.
Чтобы объявить тип, который запрещает `NULL`, надо использовать модификатор Non-Null.

Этот модификатор "обёртывает" базовый тип, и действует идентично  
содержимому, за исключением того, что `NULL` уже не является допустимым. 
Заключительный восклицательный знак используется для обозначения, что тип 
определён как Non-Null, например: `name: ID!`.

Добавление этого модификатора никак не сказывается на 
формат ответа, а влияет лишь на логику приложения и формирование ответа 
в случае ошибок (об этом мы поговорим чуть позже).

Например:

```graphql
type Query {
    user(id: ID!): User!
}

type User {
    name: String!
}
```

Подобная схема может вернуть, как и ожидается, следующий ответ:

```json
{
    "data": {
        "user": {
            "name": "Username"
        }
    }
}
```

## List

Список представляет собой специальный модификатор коллекции, который объявляет тип каждого 
элемента в списке (называемый типом элемента списка). 
Значения сериализуются как упорядоченные списки, где каждый элемент сериализуется 
в соответствии с типом этого элемента. Чтобы обозначить, что поле содержит список, 
тип элемента должен быть заключен в квадратные скобки следующим образом: `pets: [Pet]`.

Давайте посмотрим на пример выше и попробуем его модифицировать, 
учитывая новоприобретённые знания:

```graphql
type Query {
    users: [User]!
}

type User {
    name: String!
}
```

Что будет соответствовать примерно такому ответу:

```json
{
    "data": {
        "users": [
            {
                "name": "First Username"
            },
            {
                "name": "Second Username"
            }
        ]
    }
}
```

## Отказоустойчивость

Философия GraphQL состоит в композиции разнородных данных в рамках одного запроса, 
по-этому стоит заметить, что не стоит увлекаться указанием модификатора `!`, 
т.к. это "увеличивает масштаб" недоотправленных данных клиенту в случае ошибки сервера. 
Например, возьмём такой запрос:

```graphql
{
    user(id: 23) {
        friend(id: 42) {
            name
        }
    }
}
```

Если мы жёстко пропишем Non-Null для всех отношений в схеме в таком варианте:

```graphql
type Query {
    user(id: ID!): User!
}

type User {
    name: String!
    friend(id: ID!): User!
}
```

То в случае ошибки сервера "Not found" мы получим следующий ответ:

```json
{
    "data": null,
    "errors": [
        {
            "message": "Friend with id 42 not found",
            "locations": [
                {"line": 3, "column": 20}
            ],
            "path": ["user", "friend"]
        }
    ]
}
```

Но если мы чуть ослабим определение полей и укажем следующий вариант:

```graphql
type Query {
    user(id: ID!): User!
}

type User {
    name: String!
    friend(id: ID!): User # <- Например вот тут
}
```

То в ответ получим следующее:

```json
{
    "data": {
        "user": {
            "name": "Name of user 23",
            "friend": null
        }
    },
    "errors": [
        {
            "message": "Friend with id 42 not found",
            "locations": [
                {"line": 3, "column": 20}
            ],
            "path": ["user", "friend"]
        }
    ]
}
```

Таким образом мы получим больше информации от сервера и сможем минифицировать потерю данных.

Это же правило применяется и в сочетании со списком:
- `[Type]` - В случае ошибки в качестве ответа структуры, содержащей ошибки вернётся `null`.
- `[Type!]` - В случае ошибки в одном из элементов вместо списка элементов вернётся `null`.

