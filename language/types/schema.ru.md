# Schema

Каждое GraphQL-приложение требует описания схемы. 
Схема состоит из обязательного поля `query` (запросы) и необязательных 
`mutation` (обновления), и `subscription` (подписки), 
которые ссылаются на [Object](/language/types/object).

!> Обратите внимание, что использование [модификаторов](/language/modifiers) внутри 
полей схемы недопустимо!

```graphql
schema {
    # Обязательное поле
    query: RootQuery
    
    # Опциональное поле
    mutation: RootMutation
    
    # Опциональное поле
    subscription: RootSubscription
}
```

Эти поля отличаются только семантикой и не содержат никаких других 
отличительных признаков:

- Поле `query` содержит объект, который предоставляет набор 
методов API, которые предоставляют данные клиентскому приложению.

- Поле `mutation` содержит объект, который предоставляет набор
методов API, которые позволяют создавать или обновлять данные.

- Поле `subscription` содержит объект, который предоставляет
набор методов API, которые позволяют подписываться на обновления 
внутри системы. Подписки, в отличии от обычных запросов, реализуются поверх 
протоколов/механизмов реального времени, таких как 
[long polling](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F_push) или 
[WebSocket](https://ru.wikipedia.org/wiki/WebSocket).

## Запросы

Секция `query` отвечает за обработку запросов от клиента, которые просят сервер **отдать данные** в требуемом виде. 
Объект, на который ссылается поле `query` специфицирует все запросы клиента. В качестве его значения должен выступать 
тип [Object](/sdl/object).

```graphql
schema {
    # Схема ссылается на корневой объект RootQuery
    query: RootQuery
}

# Набор запросов на API
type RootQuery {
    # Поле, возвращающее список пользователей
    users: [User]!
    
    # Поле, возвращающее список ботов
    bots: [Bot]!
}

# Объект пользователя
type User {
    id: ID!
    name: String!
}

# Объект бота
type Bot {
    id: ID!
    name: String!
}
```

## Мутации (обновления)

Секция `mutation` отвечает за обработку запросов, которые просят сервер **обновить данные**. 
Тип, на который ссылается поле `mutation` специфицирует все запросы клиента. В качестве значения `mutation` 
должен выступать тип [Object](/sdl/object).

```graphql
schema {
    query: RootQuery
    
    # Поле схемы, ссылающееся на объект мутаций
    mutation: RootMutation
}

type RootMutation {
    # Поле мутации, которое принимает новые данные пользователя 
    # в качестве аргумента и возвращает объект Response
    updateUser(user: UserInput!): Response!
}

# Пример объекта Response
type Response {
    code: Int!
    error: String
    data: Any 
}

# Новые данные пользователя. Т.к. его идентификатор является
# константным значением, то поле id можно считать идентификатором 
# пользователя, данные которого следует обновить.
input UserInput {
    id: ID!
    name: String!
}
```

## Именованные схемы

> RL/SDL >= 1.2

В тех случаях, когда ваше приложение требует нескольких точек 
доступа имеет смысл использовать именованные схемы. 
Таким образом мы можем выбирать что именно можно использовать клиенту 
без необходимости ему сообщать куда конкретно обращаться.

Данный функционал **не рекомендуется** использовать для разграничения 
прав и нужен лишь для "жёсткого" разграничения различных частей приложения, 
которые отличаются не только по возможностям, но и по смыслу. 

```graphql
schema {
    query: PublicApi
}

schema Admin {
    query: AdminApi
}
```
