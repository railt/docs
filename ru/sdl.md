# RL/SDL

## GraphQL vs SDL

Разработчики, которые только начали знакомиться с технологией GraphQL
совершают идентичные ошибки: Путают определения 
**GraphQL** и <abbr title="Schema Definition Language">SDL</abbr>. 
В рамках стека GraphQL (_"Graph Query Language"_) 
SDL отвечает за описание схемы, которой оперирует сам язык запросов и который
в некоторых реализациях предоставляется GraphQL сервером для описания его (сервера) работы.

Такая путаница появилась по историческим причинам: Команда фронт-энд разработки Facebook
решила реализовать спецификацию некого языка для упрощения работы со своим сервером,
которая бы позволила оперировать сложными структурами, способами и вариантами их получения 
и проч. 

В отличие от SQL - реализация должна быть:
1) Безопасной.
2) Читаемой и понятной для большинства веб-разработчиков, привыкших к JSON.
3) Расширяемой.
4) Удобной для получения данных _относительно_ любой сложности.

Помимо этого клиент должен был изначально знать какие данные в каком виде можно 
получить, а так же иметь полное представление о том, 
кто за что отвечает - документацию.

Т.к. изначально инициаторами был именно фронт-энд отдел, то первая реализация полного 
клиент-серверно стека GraphQL была реализована на JavaScript, при этом реализация
севера представляла из себя код, вида "`new GraphQLObject({name: 'name', ...})`" (это важно), 
т.к. на тот момент была важна стабилизация и структуризация существующих решений. 

Первая публичная спецификация языка запросов GraphQL увидела свет в 
[октябре 2015го](http://facebook.github.io/graphql/October2015/) года, 
хотя сам язык во внутреннем стеке Facebook использовался и ранее,
примерно за 2-3 года до первой публичной версии.

Результат работы отдела стал настолько значимым, что им заинтересовалось огромное 
количество специалистов по всему миру и появились стартапы, вроде GraphQL SAAS решения 
[graph.cool](https://www.graph.cool/docs/reference/schema/overview-ahwoh2fohj/), которые
предлагали совместимый синтаксис для декларации схем, который позже стал поддерживаться 
[официальной JavaScript библиотекой](https://github.com/graphql/graphql-js) и получил 
название SDL-языка, а так как система деларации типов неотделима от GraphQL - 
её синтаксис поддержали в [документации GraphQL](http://graphql.org/) для примеров, 
при этом не предоставив никакой спецификации по синтаксису и возможностям. 

Обсуждение возможностей схемы обсуждается в
[Pull Request #90](https://github.com/facebook/graphql/pull/90), но 
не специфицировано. По-этому реализация Railt, хоть и придерживается 
утверждённой (и допустимой в будущем) спецификации GraphQL SDL, но носит название 
**RL/SDL** (_Railt Schema Definition Language_), т.к. поведение и некоторые возможности 
могут отличаться от JavaScript реализации, хотя и являются обратно совместимой.

Ниже мы постараемся подробнее разобрать отличия декларации схемы от языка запросов, 
а так же полностью разобрать что из себя представляет серверный GraphQL **RL/SDL** язык.  

## SDL Схема

Каждое **GraphQL API** начинается с описания схемы. 
Такие схемы в терминах GraphQL называются 
<abbr title="Interface Definition Language">IDL</abbr>, 
<abbr title="Schema Definition Language">SDL</abbr> или 
<abbr title="Object Type Definition">OTD</abbr>.

Например, наше API должно возвращать 
список пользователей и иметь возможность получить какого-то одного 
по идентификатору. В этом случае схема запроса может выглядеть следующим образом:  

```graphql
schema {
    # Это поле схемы ссылается на основной набор запросов вашего API.
    query: UsersApi
}

# Этот тип - объект, содержит набор полей, которые доступны в нашем API.
type UsersApi {
    # Поле пользователя (user) принимает один обязательный аргумент 
    # с типом "ID" - идентификатор требуемого пользователя и может 
    # возвращать объект пользвователя. 
    user(id: ID!): User
    
    # Поле пользователей (users) всегда возвращает список объектов 
    # пользователей.
    users: [User]!
}


# Объект пользователя - структура, которая будет возвращаться в ответах. 
type User {
    # Идентификатор нашего пользователя
    id: ID!
    
    # Имя пользователя
    login: String!
    
    # Дата создания пользователя
    createdAt: DateTime!
    
    # Дата обновления аккаунта пользователя.
    # Стоит заметить, что у возвращаемого типа нет символа "!" в конце.
    # Это значит, что в качестве результата этого поля может вернуться null.
    updatedAt: DateTime
}
```

## Запросы

Вышеприведённая схема описывает все допустимые запросы, их структуру 
и возвращаемые типы. Но для того чтобы воспользоваться её возможностями
следует сформировать нужный запрос. Подробнее о запросах можно 
почитать в [официальной документации](http://graphql.org/learn/queries/), 
здесь же мы остановимся непосредственно на примере запроса для описанной 
выше схемы, а так же ответе на этот запрос:

```graphql
{
    users {
        id
        login
    }
    
    user (42) {
        id
        createdAt
    }
}
``` 
 
Такой запрос должен сформировать примерно следующий ответ:

```json
{
    "users": [
        {
            "id": 23,
            "login": "Erwin Rudolf Josef Alexander Schrödinger"
        },
        {
            "id": 42,
            "login": "Max Otto von Stierlitz"
        }
    ],
    "user": {
        "id": 42,
        "createdAt": "1900-10-08T23:16:00+00:00"
    }
}
```


