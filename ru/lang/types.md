# Объявления типов

...

## Переопределение и перегрузка

RL/SDL содержит набор алгебраических типов. Как говорит 
[Википедия](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%82%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85):
  
> Алгебраи́ческий тип да́нных — в информатике наиболее общий составной тип, представляющий 
собой тип-сумму из типов-произведений. Алгебраический тип имеет набор конструкторов, 
каждый из которых принимает на вход значения определённых типов и возвращает значение 
конструируемого типа.

Если говорить простым языком — это обычная иерархия типов, где потомок 
наследует поведение родителя. Давайте взглянем на следующую схему:

```accord
→ Any
    → String
        → Float
            → Int
    → Bool
    → ID
    → DateTime
```

Без подробного пояснения смысла схемы — она довольно бессмысленна.
 
Данная схема обозначает правила перегрузки (переопределения) скалярных 
типов данных во время наследования, следуя правилам [LSP](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BF%D0%BE%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8_%D0%91%D0%B0%D1%80%D0%B1%D0%B0%D1%80%D1%8B_%D0%9B%D0%B8%D1%81%D0%BA%D0%BE%D0%B2).

> - Предусловия не могут быть усилены в подклассе.
> - Постусловия не могут быть ослаблены в подклассе.

Перегрузка типов допустима (проявляется) в следующих случаях:
- Во время [реализации интерфейса](/sdl/interface) каким-либо объектом.
- Во время [наследования интерфейсов](https://github.com/railt/railt/issues/38).
- Во время [расширения типов](/sdl/extend).

Учитывая вышеизложенные правила мы получаем следующую картину.

## Предусловия

Давайте рассмотрим на примерах с типами и интерфейсами, 
какие случаи "ослаблений и "усилений" возможны, а какие недопустимы.

```graphql
interface ExampleInterface {
    field(arg: String): String
    #          ^^^^^^ - Обратите внимание на тип аргумента родителя...
}

type ExampleType implements ExampleInterface {
    field(arg: Any): String
    #          ^^^ - ... и потомка.
}
```

Такой пример является допустимым и рабочим, т.к. тип "`String`" 
является потомком "`Any`", а значит является допустимым "ослаблением" предусловия.

Помимо этого такие же правила действуют на `NonNull` модификатор:

```graphql
interface ExampleInterface {
    field(arg: String!): String
    #                ^ - Обратите внимание на то, что возвращаемый тип родителя является NonNull.
}

type ExampleType implements ExampleInterface {
    field(arg: String): String
    #                ^ - Потомок при этом является NULL или "String".
}
```

Естественно, что в обратную сторону подобное недопустимо и вызовет ошибку компиляции.

```graphql
interface ExampleInterface {
    field(arg: String): String
}

type ExampleType implements ExampleInterface {
    field(arg: String!): String
    # Error on line 6 at position 4 in field "field": Nullable argument "arg" can not be overriden by NonNull
}
```


## Постусловия

Таким же образом происходит и с постусловиями, но ровно в обратном порядке.

```graphql
interface ExampleInterface {
    field: Any
    #      ^^^ - Возвращаемый тип Any 
}

type ExampleType implements ExampleInterface {
    field: String
    #      ^^^^^^ - Может быть переопределёгн типом String
}
```
