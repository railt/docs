# Система типов

Платформа GraphQL содержит набор из нескольких разных типов, которые позволяют 
оперировать структурой API, комбинировать значения и получать конкретные данные.

Каждый тип содержит три характеристики, которые мы разберём ниже:
1) Время и место определения и выполнения.
2) Допустимость для передачи со стороны клиента и возвращению со стороны сервера.
3) Самостоятельность.

## Объявление и вызов

Важно отметить, что GraphQL - является не только языком запросов. Это технологический стек или платформа, 
которая состоит из объявления типов и их вызова, т.е. из декларативной и императивных составляющих.

Объявление объекта "User" выглдит следующим образом:

```graphql
schema {
    query: Api
}

type Api {
    user: User!
}

type User {
    id: ID!
    name: String!
    friends: [User!]!
}
```

Сам вызов типов, в противоположность объявлению, используется в основном на клиентской стороне, 
однако существуют и исключения, типы, вызовы которых доступны везде.

Типичный вызов объекта со стороны клиента должен сопровождаться получением информации из конкретного поля. 
Не обязательно перечислять все поля объекта (в примере, у объекта пользователя выше их 3), но как 
минимум одно должно быть указано явно. Например, чтобы получить пользователя, его имя и имена 
всех его друзей нужно составить такой запрос:

```graphql
query {             # Обращаемся к "query" у схемы "schema".
    user {          # Получаем поле "user" у объекта "Api". Т.к. это объект мы обязаны указать поля.
        name        # Получаем поле "name" у объекта "User". Поле объявлено как скаляр, никаких потомков не требуется.
        friends {   # Получаем поле "friends" у объекта "User".
            name    # Получаем поле "name" у объекта "User". Т.е. у каждого из друзей родительского пользователя.
        }
    }
}
``` 

## Исходящие и входящие типы

Каждый тип содержит харакетристику, которая отвечает за то, будет ли тип входящим (In), 
т.е. доступен для передачи/вызова извне, из клиента, или будет исходящим (Out), возвращаемым с сервера.

Грубо говоря, входящим тип является только тогда, когда допустим в качестве определения аргумента (Argument) 
или объявляется на клиенте. Исходящим - только тогда, когда допустим в качестве определения поля (Field) 
или клиент умеет оперировать его определением.

В частности, объект является только возвращаемым, его объявление допустимо только в полях 
и передача в качестве аргумента невозможна. Однако, скалярный тип является как возвращаемым, 
так и передаваемым, мы можем получить его значение с сервера и передать какое-либо обратно.

**Входящий*
1) Объявлен на сервере и используется в аргументах.
2) Объявлен на клиенте.

**Исходящий**
1) Объявлен на сервере и используется в полях.
2) Клиент умеет оперировать им в запросе.

## Зависимые типы

Из примера выше мы почерпнули то, что объект "User" 
содержит дополнительные характеристики - поля. Поля не являются 
составной частью объектов, а представляют из себя зависимый тип Field, 
в данном случае от объекта "User".

## Таблица соответсвия

?> Прим.: Под "документом" подразумевается файл на сервере с описанием схемы. Под "запросом" - GraphQL запрос.

| Тип            | Объявление | Вызов    | In | Out | Родитель                   |
|----------------|------------|----------|----|-----|----------------------------|
| Alias          | _клиент_   | _сервер_ | ✓  | ✓   | Field                      |
| Argument       | _сервер_   | _везде_  | ✓  | ✕   | Field, Input, Directive    |
| Directive      | _сервер_   | _везде_  | ✓  | ✕   | _Все типы_                 |
| Enum           | _сервер_   | _везде_  | ✓  | ✕   | **Документ**               |
| EnumValue      | _сервер_   | _везде_  | ✓  | ✓   | Enum                       |
| Extension      | _сервер_   | _сервер_ | ✕  | ✕   | _Все типы в **документе**_ |
| Field          | _сервер_   | _клиент_ | ✓  | ✓   | Interface, Object          |
| Fragment       | _клиент_   | _сервер_ | ✓  | ✕   | **Запрос**                 |
| InlineFragment | _клиент_   | _сервер_ | ✓  | ✕   | Interface, Union           |
| Interface      | _сервер_   | _везде_  | ✕  | ✓   | **Документ**               |
| Input          | _сервер_   | _везде_  | ✓  | ✓   | **Документ**               |
| Object         | _сервер_   | _везде_  | ✕  | ✓   | **Документ**               |
| Scalar         | _сервер_   | _везде_  | ✓  | ✓   | **Документ**               |
| Schema         | _сервер_   | _клиент_ | ✕  | ✕   | **Документ**               |
| Union          | _сервер_   | _клиент_ | ✕  | ✓   | **Документ**               |
| Variable       | _клиент_   | _сервер_ | ✓  | ✕   | Schema, Argument           |

## Переопределение и перегрузка

RL/SDL содержит набор алгебраических типов. Как говорит 
[Википедия](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%82%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85):
  
> Алгебраи́ческий тип да́нных — в информатике наиболее общий составной тип, представляющий 
собой тип-сумму из типов-произведений. Алгебраический тип имеет набор конструкторов, 
каждый из которых принимает на вход значения определённых типов и возвращает значение 
конструируемого типа.

Если говорить простым языком — это обычная иерархия типов, где потомок 
наследует поведение родителя. Давайте взглянем на следующую схему:

```accord
→ Any
    → String
        → Float
            → Int
    → Bool
    → ID
    → DateTime
```

Без подробного пояснения смысла схемы — она довольно бессмысленна.
 
Данная схема обозначает правила перегрузки (переопределения) скалярных 
типов данных во время наследования, следуя правилам [LSP](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BF%D0%BE%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8_%D0%91%D0%B0%D1%80%D0%B1%D0%B0%D1%80%D1%8B_%D0%9B%D0%B8%D1%81%D0%BA%D0%BE%D0%B2).

> - Предусловия не могут быть усилены в подклассе.
> - Постусловия не могут быть ослаблены в подклассе.

Перегрузка типов допустима (проявляется) в следующих случаях:
- Во время [реализации интерфейса](/sdl/interface) каким-либо объектом.
- Во время [наследования интерфейсов](https://github.com/railt/railt/issues/38).
- Во время [расширения типов](/sdl/extend).

Учитывая вышеизложенные правила мы получаем следующую картину.

## Предусловия

Давайте рассмотрим на примерах с типами и интерфейсами, 
какие случаи "ослаблений и "усилений" возможны, а какие недопустимы.

```graphql
interface ExampleInterface {
    field(arg: String): String
    #          ^^^^^^ - Обратите внимание на тип аргумента родителя...
}

type ExampleType implements ExampleInterface {
    field(arg: Any): String
    #          ^^^ - ... и потомка.
}
```

Такой пример является допустимым и рабочим, т.к. тип "`String`" 
является потомком "`Any`", а значит является допустимым "ослаблением" предусловия.

Помимо этого такие же правила действуют на `NonNull` модификатор:

```graphql
interface ExampleInterface {
    field(arg: String!): String
    #                ^ - Обратите внимание на то, что возвращаемый тип родителя является NonNull.
}

type ExampleType implements ExampleInterface {
    field(arg: String): String
    #                ^ - Потомок при этом является NULL или "String".
}
```

Естественно, что в обратную сторону подобное недопустимо и вызовет ошибку компиляции.

```graphql
interface ExampleInterface {
    field(arg: String): String
}

type ExampleType implements ExampleInterface {
    field(arg: String!): String
    # Error on line 6 at position 4 in field "field": Nullable argument "arg" can not be overriden by NonNull
}
```


## Постусловия

Таким же образом происходит и с постусловиями, но ровно в обратном порядке.

```graphql
interface ExampleInterface {
    field: Any
    #      ^^^ - Возвращаемый тип Any 
}

type ExampleType implements ExampleInterface {
    field: String
    #      ^^^^^^ - Может быть переопределёгн типом String
}
```
