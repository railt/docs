# Interface

Как и многие системы типов, GraphQL поддерживает интерфейсы. 
Интерфейс представляет собой абстрактный тип, который содержит 
определенный набор полей, которые должен содержать объект 
реализующий этот интерфейс.

Например, у вас может быть интерфейс `Person`, который представляет 
некого абстрактного пользователя:

```graphql
interface Person {
    id: ID!
    name: String
    createdAt: DateTime!
}
```

Это означает, что любой объект, который реализует интерфейс `Person`, 
должен иметь эти поля с этими аргументами.

А теперь представим, что есть некоторые объекты, 
которые могут реализовать интерфейс `Person`:

```graphql
type User implements Person {
    id: ID!
    name: String!
    email: String!
    createdAt: DateTime!
}

type Bot implements Person {
    id: ID!
    name: String
    createdAt: DateTime!
}
```

Вы можете видеть, что оба эти объекта имеют все поля из интерфейса 
`Person`, но также предоставляют дополнительные. В частности, 
объект `User`, помимо обязательных `id`, `name` и `createdAt` содержит 
ещё одно — `name`.

Интерфейсы полезны, когда вы хотите вернуть объект или набор объектов, 
но они могут быть нескольких разных типов.

## Переопределение

!> В отличии от официальной спецификации, которая описана одной 
строчкой "поля должны быть того же типа", реализация Railt гибче 
и содержит более мощную систему типов. По-этому, дальнейшие
примеры могут не воспроизводиться в других реализациях, 
поддерживающих <abbr title="Schema Definition Language">SDL</abbr>, 
например [GraphQL JS](https://github.com/graphql/graphql-js).

Вы могли заметить и подумать, что это опечатка, но поле
`name` у объекта `User` в примере выше содержит тип `name: String!`, 
хотя интерфейс `Person` специфицирован полем `name: String`. 

Во время реализации интерфейса (а так же в случае [расширения](/sdl/extend)) 
можно переопределять типы полей, типы аргументов, а так же их количество.

В качестве "потомка" этого типа может выступать либо такой же тип, что 
довольно очевидно, либо такой же, но более строгий. Под "строгим" имеется 
ввиду переопределение `nullable` типа модификатором `NonNull` 
(в том числе и для списочных типов). 

Помимо этого такие возможности содержат и скаляры. На 
[соответсвующей странице](/sdl/scalar) представлена иерархия 
скалярных типов. Под более "строгим" типом подразумевается потомок,
или производный скаляр от базового. Например, таким образом 
допустима следующая ситуация:

```graphql
interface Response {
    message: Any
}

type AnswerResponse implements Response {
    message: String!
}

type DateResponse implements Response {
    message: DateTime!
}
```    

